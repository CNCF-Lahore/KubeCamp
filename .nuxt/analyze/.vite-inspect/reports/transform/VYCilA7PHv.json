{
  "resolvedId": "/workspace/Kubernetes-Bootcamp/node_modules/pinceau/dist/runtime.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { ref, computed, watch, onScopeDispose, unref, getCurrentInstance, inject } from 'vue';\nimport { nanoid } from 'nanoid';\nimport { z as stringify, a as resolveCssProperty, c as createTokensHelper, s as set, h as get, n as normalizeConfig, w as walkTokens, p as pathToVarName, e as resolveReferences, g as resolveThemeRule } from './shared/pinceau.3988746b.mjs';\nimport { kebabCase } from 'scule';\nimport { defu } from 'defu';\n\nconst HYDRATION_SELECTOR = \".phy[--]\";\nfunction usePinceauRuntimeSheet($tokens, initialUtils = {}, colorSchemeMode, appId) {\n  const sheet = ref();\n  const utils = ref(initialUtils);\n  const cache = {};\n  const stringify$1 = (decl, loc) => stringify(\n    decl,\n    (property, value, style, selectors) => resolveCssProperty(\n      property,\n      value,\n      style,\n      selectors,\n      [],\n      { $tokens, utils: utils.value, options: { colorSchemeMode, runtime: true } },\n      loc\n    )\n  );\n  function resolveStylesheet() {\n    const global = globalThis || window;\n    let style;\n    let hydratableSheet;\n    if (global && global.document) {\n      const fullId = `pinceau-runtime${appId ? `-${appId}` : \"\"}`;\n      const doc = global.document;\n      style = doc.querySelector(`style#${fullId}`);\n      if (!style) {\n        const styleNode = doc.createElement(\"style\");\n        styleNode.id = fullId;\n        styleNode.type = \"text/css\";\n        style = doc.head.appendChild(styleNode);\n      }\n      hydratableSheet = doc.querySelector(`style#pinceau-runtime-hydratable${appId ? `-${appId}` : \"\"}`);\n    }\n    sheet.value = style?.sheet || getSSRStylesheet();\n    return hydratableSheet ? hydrateStylesheet(hydratableSheet) : void 0;\n  }\n  function hydrateStylesheet(el) {\n    const hydratableRules2 = {};\n    for (const _rule of Object.entries(el?.sheet?.cssRules || sheet.value?.cssRules || {})) {\n      const [index, rule] = _rule;\n      const uids = resolveUid(rule);\n      if (!uids || !uids.uid) {\n        continue;\n      }\n      if (!hydratableRules2[uids.uid]) {\n        hydratableRules2[uids.uid] = {};\n      }\n      const newIndex = sheet.value.insertRule(rule.cssText, Number(index));\n      hydratableRules2[uids.uid][uids.type] = sheet.value.cssRules.item(newIndex);\n    }\n    if (el) {\n      el.remove();\n    }\n    return hydratableRules2;\n  }\n  function toString() {\n    if (!sheet.value) {\n      return \"\";\n    }\n    return Object.entries(sheet.value.cssRules).reduce(\n      (acc, [, rule]) => {\n        acc += `${rule?.cssText} ` || \"\";\n        return acc;\n      },\n      \"\"\n    );\n  }\n  function pushDeclaration(uid, type, declaration, previousRule, loc) {\n    if (!Object.keys(declaration).length) {\n      return;\n    }\n    const cssText = stringify$1(\n      {\n        \"@media\": {\n          // Mark inserted declaration with unique id and type of runtime style\n          [HYDRATION_SELECTOR]: { \"--puid\": `${uid}-${type}` },\n          ...declaration\n        }\n      },\n      loc\n    );\n    if (!cssText) {\n      return;\n    }\n    if (previousRule) {\n      deleteRule(previousRule);\n    }\n    const ruleId = sheet.value.insertRule(cssText);\n    return sheet.value.cssRules[ruleId];\n  }\n  function deleteRule(rule) {\n    const ruleIndex = Object.values(sheet.value.cssRules).indexOf(rule);\n    if (typeof ruleIndex === \"undefined\" || isNaN(ruleIndex)) {\n      return;\n    }\n    try {\n      sheet.value.deleteRule(ruleIndex);\n    } catch (e) {\n    }\n  }\n  const hydratableRules = resolveStylesheet();\n  return {\n    stringify: stringify$1,\n    cache,\n    pushDeclaration,\n    deleteRule,\n    sheet,\n    toString,\n    hydratableRules\n  };\n}\nfunction getSSRStylesheet() {\n  return {\n    cssRules: [],\n    insertRule(cssText, index = this.cssRules.length) {\n      this.cssRules.splice(index, 1, { cssText });\n      return index;\n    },\n    deleteRule(index) {\n      delete this.cssRules[index];\n    }\n  };\n}\nfunction resolveUid(rule) {\n  const uidRule = rule.cssRules && rule.cssRules.length ? Object.entries(rule?.cssRules).find(([_, rule2]) => rule2.selectorText === HYDRATION_SELECTOR) : void 0;\n  if (!uidRule) {\n    return;\n  }\n  const uidRegex = /--puid:(.*)?-(c|v|p)?/m;\n  const [, uid, type] = uidRule[1].cssText.match(uidRegex);\n  if (!uid) {\n    return;\n  }\n  return { uid, type };\n}\n\nfunction usePinceauRuntimeIds(instance, classes, _) {\n  let uid;\n  const el = instance?.vnode?.el;\n  if (el && el.classList) {\n    el.classList.forEach(\n      (elClass) => {\n        if (uid) {\n          return;\n        }\n        if (elClass.startsWith(\"pc-\")) {\n          uid = elClass.split(\"pc-\")[1];\n        }\n      }\n    );\n  } else {\n    uid = nanoid(6);\n  }\n  const scopeId = instance?.vnode?.type?.__scopeId;\n  const ids = {\n    uid,\n    componentId: scopeId ? `[${scopeId}]` : \"\",\n    uniqueClassName: `pc-${uid}`\n  };\n  classes.value.c = ids.uniqueClassName;\n  return computed(() => ids);\n}\n\nfunction usePinceauThemeSheet(initialTheme, tokensHelperConfig = {}, colorSchemeMode) {\n  const sheet = ref();\n  const theme = ref(initialTheme || {});\n  tokensHelperConfig = Object.assign(\n    {\n      key: \"variable\"\n    },\n    tokensHelperConfig || {}\n  );\n  const $tokens = createTokensHelper(\n    theme,\n    tokensHelperConfig\n  );\n  let cache = {};\n  resolveStylesheet();\n  if (import.meta.hot) {\n    import.meta.hot.on(\n      \"pinceau:themeUpdate\",\n      (newTheme) => {\n        const styleNode = document.createElement(\"style\");\n        styleNode.id = \"pinceau-theme\";\n        styleNode.textContent = newTheme.css;\n        sheet.value.ownerNode.replaceWith(styleNode);\n        sheet.value = styleNode.sheet;\n        hydrateStylesheet(sheet.value.cssRules);\n      }\n    );\n  }\n  function findThemeSheet(document2) {\n    for (const sheet2 of document2.styleSheets) {\n      if (sheet2?.ownerNode?.textContent.includes(\"--pinceau-mq\")) {\n        return sheet2.ownerNode;\n      }\n    }\n  }\n  function resolveStylesheet() {\n    const global = globalThis || window;\n    if (global && global.document) {\n      let sheetElement = document.querySelector(\"#pinceau-theme\");\n      if (!sheetElement) {\n        sheetElement = findThemeSheet(document);\n      }\n      sheet.value = sheetElement?.sheet;\n      if (sheet.value) {\n        hydrateStylesheet(sheet.value?.cssRules);\n      }\n    }\n  }\n  function hydrateStylesheet(cssRules) {\n    cache = {};\n    Object.entries(cssRules || {}).forEach(\n      ([_, rule]) => {\n        if (rule?.type !== 4 && !rule?.cssText?.includes(\"--pinceau-mq\")) {\n          return false;\n        }\n        let currentTheme = \"initial\";\n        rule.cssText.match(/--([\\w-]+)\\s*:\\s*(.+?);/gm)?.forEach((match) => {\n          const [variable, value] = match.replace(\";\", \"\").split(/:\\s(.*)/s);\n          if (variable === \"--pinceau-mq\") {\n            currentTheme = value;\n            if (!cache[value]) {\n              const ruleReference = Object.entries(rule?.cssRules || {}).find(([_2, cssRule]) => cssRule?.cssText.includes(`--pinceau-mq: ${value}`))?.[1];\n              if (ruleReference) {\n                cache[value] = ruleReference;\n              }\n            }\n            return;\n          }\n          const path = [...variable.substring(2).split(\"-\")];\n          set(theme.value, path, getSetValue(path, value, variable, currentTheme));\n        });\n      }\n    );\n  }\n  function updateTheme(value) {\n    const mqKeys = Array.from(/* @__PURE__ */ new Set([\"dark\", \"light\", ...Object.keys(value?.media || {}), ...Object.keys(theme.value?.media || {})]));\n    const config = normalizeConfig(value || {}, mqKeys, true);\n    walkTokens(config, (token, _, paths) => updateToken(paths, token.value));\n  }\n  function updateToken(path, value, mq = \"initial\") {\n    if (typeof value === \"object\") {\n      Object.entries(value).forEach(([mq2, mqValue]) => updateToken(path, mqValue, mq2));\n      return;\n    }\n    const varName = pathToVarName(path);\n    if (!cache?.[mq]) {\n      createMqRule(mq);\n    }\n    const resolvedValue = resolveReferences(void 0, value, [], { $tokens });\n    set(\n      theme.value,\n      path,\n      getSetValue(path, resolvedValue, varName, mq)\n    );\n    cache?.[mq]?.style.setProperty(varName, resolvedValue);\n  }\n  function reactiveToken(path) {\n    return computed(\n      {\n        get() {\n          return get(theme.value, `${path}.value`);\n        },\n        set(v) {\n          updateToken(path, v);\n        }\n      }\n    );\n  }\n  function getSetValue(path, value, variable, mq = \"initial\") {\n    const setValue = { value, variable: `var(${variable})` };\n    const existingValue = get(theme.value, path);\n    if (existingValue && !variable.startsWith(\"--media\")) {\n      if (typeof existingValue?.value === \"object\") {\n        setValue.value = { ...existingValue.value, [mq]: value };\n      } else {\n        setValue.value = { initial: existingValue.value, [mq]: value };\n      }\n    }\n    return setValue;\n  }\n  function createMqRule(mq) {\n    if (cache?.[mq]) {\n      return cache?.[mq];\n    }\n    const mqRule = resolveThemeRule(mq, \"\", theme.value, colorSchemeMode);\n    const newRule = sheet.value.insertRule(mqRule, sheet.value.cssRules.length);\n    cache[mq] = sheet.value.cssRules.item(newRule).cssRules[0];\n    return cache[mq];\n  }\n  return {\n    $tokens,\n    updateToken,\n    updateTheme,\n    reactiveToken,\n    resolveStylesheet,\n    theme\n  };\n}\n\nfunction usePinceauComputedStyles(ids, computedStyles, sheet, loc) {\n  let rule = sheet.hydratableRules?.[ids.value.uid]?.c;\n  watch(\n    () => computedStyles,\n    (newComputedStyles) => {\n      newComputedStyles = computedStylesToDeclaration(ids.value, newComputedStyles);\n      rule = sheet.pushDeclaration(\n        ids.value.uid,\n        \"c\",\n        newComputedStyles,\n        rule,\n        { ...loc, type: \"c\" }\n      );\n    },\n    {\n      immediate: !rule,\n      deep: true\n    }\n  );\n  onScopeDispose(() => rule && sheet.deleteRule(rule));\n}\nfunction computedStylesToDeclaration(ids, computedStyles) {\n  const declaration = {};\n  const targetId = `.${ids.uniqueClassName}${ids.componentId}`;\n  if (computedStyles && Object.keys(computedStyles).length) {\n    declaration[targetId] = declaration[targetId] || {};\n    for (const [varName, _value] of Object.entries(computedStyles)) {\n      const value = unref(_value);\n      if (varName === \"css\") {\n        declaration[targetId] = Object.assign(declaration[targetId], value);\n        continue;\n      }\n      if (typeof value === \"object\") {\n        for (const [mqId, mqPropValue] of Object.entries(value)) {\n          const _value2 = unref(mqPropValue);\n          if (!_value2) {\n            continue;\n          }\n          if (mqId === \"initial\") {\n            if (!declaration[targetId]) {\n              declaration[targetId] = {};\n            }\n            if (!declaration[targetId]) {\n              declaration[targetId] = {};\n            }\n            declaration[targetId][`--${varName}`] = _value2;\n          }\n          const mediaId = `@${mqId}`;\n          if (!declaration[mediaId]) {\n            declaration[mediaId] = {};\n          }\n          if (!declaration[mediaId][targetId]) {\n            declaration[mediaId][targetId] = {};\n          }\n          declaration[mediaId][targetId][`--${kebabCase(varName)}`] = _value2;\n        }\n      } else {\n        const _value2 = unref(value);\n        if (_value2) {\n          declaration[targetId][`--${kebabCase(varName)}`] = _value2;\n        }\n      }\n    }\n  }\n  return declaration;\n}\n\nconst usePinceauVariants = (ids, variants, props, sheet, classes, loc) => {\n  let rule = sheet.hydratableRules?.[ids.value.uid]?.v;\n  const variantsState = computed(() => variants ? resolveVariantsState(ids.value, props, variants) : {});\n  const variantsClasses = ref([]);\n  watch(\n    variantsState,\n    ({ cacheId, variantsProps }) => {\n      let variantClass;\n      if (sheet.cache[cacheId]) {\n        const cachedRule = sheet.cache[cacheId];\n        rule = cachedRule.rule;\n        variantClass = cachedRule.variantClass;\n        if (cachedRule?.classes) {\n          variantsClasses.value = cachedRule.classes;\n        }\n        cachedRule.count++;\n      } else {\n        variantClass = `pv-${nanoid(6)}`;\n        const { declaration, classes: classes2 } = variantsToDeclaration(variantClass, ids.value, variants, variantsProps);\n        variantsClasses.value = classes2;\n        rule = sheet.pushDeclaration(ids.value.uid, \"v\", declaration, void 0, { ...loc, type: \"v\" });\n        sheet.cache[cacheId] = { rule, variantClass, classes: classes2, count: 1 };\n      }\n      classes.value.v = variantClass;\n    },\n    {\n      immediate: true\n    }\n  );\n  onScopeDispose(\n    () => {\n      const state = variantsState?.value;\n      const cachedRule = sheet.cache?.[state.cacheId];\n      if (cachedRule) {\n        cachedRule.count--;\n        if (cachedRule.count <= 0) {\n          sheet.deleteRule(cachedRule.rule);\n          delete sheet.cache[state.cacheId];\n        }\n      }\n    }\n  );\n  return { variantsClasses };\n};\nfunction variantsToDeclaration(variantClass, ids, variants, props) {\n  let classes = [];\n  const declaration = {};\n  if (props && Object.keys(props).length) {\n    const targetId = `.${variantClass}`;\n    for (const [propName, propValue] of Object.entries(props)) {\n      if (typeof propValue === \"object\") {\n        for (const [mqId, mqPropValue] of Object.entries(propValue)) {\n          const _value = mqPropValue?.toString() || mqPropValue;\n          const variantValue = variants[propName][_value];\n          if (!variantValue) {\n            continue;\n          }\n          if (!declaration[targetId]) {\n            declaration[targetId] = {};\n          }\n          if (typeof variantValue === \"string\" || Array.isArray(variantValue) || variantValue?.$class) {\n            const classAttr = typeof variantValue === \"string\" || Array.isArray(variantValue) ? variantValue : variantValue.$class;\n            classes = [\n              ...classes,\n              ...typeof classAttr === \"string\" ? classAttr.split(\" \") : classAttr\n            ];\n            delete variantValue.$class;\n          }\n          if (mqId === \"initial\") {\n            if (!declaration[targetId]) {\n              declaration[targetId] = {};\n            }\n            declaration[targetId] = defu(declaration[targetId], variantValue);\n          }\n          const mediaId = `@${mqId}`;\n          if (!declaration[mediaId]) {\n            declaration[mediaId] = {};\n          }\n          if (!declaration[mediaId][targetId]) {\n            declaration[mediaId][targetId] = {};\n          }\n          declaration[mediaId][targetId] = defu(declaration[mediaId][targetId], variantValue);\n        }\n      } else {\n        const _value = propValue?.toString?.() || propValue;\n        const variantValue = variants?.[propName]?.[_value];\n        if (!variantValue) {\n          continue;\n        }\n        if (!declaration[targetId]) {\n          declaration[targetId] = {};\n        }\n        declaration[targetId] = defu(declaration[targetId], variantValue);\n      }\n    }\n  }\n  return { declaration, classes };\n}\nfunction resolveVariantsState(ids, props, variants) {\n  if (!props || !variants) {\n    return {};\n  }\n  let cacheId = ids.componentId;\n  const variantsProps = Object.entries(props).reduce(\n    (acc, [propName, propValue]) => {\n      if (!variants[propName]) {\n        return acc;\n      }\n      if (typeof propValue === \"object\") {\n        Object.entries(propValue).forEach(([key, value]) => cacheId += `${propName}:${key}:${value}|`);\n      } else {\n        cacheId += `${propName}:${propValue}|`;\n      }\n      acc[propName] = propValue;\n      return acc;\n    },\n    {}\n  );\n  return { cacheId, variantsProps };\n}\n\nfunction usePinceauCssProp(ids, props, sheet, loc) {\n  let rule = sheet.hydratableRules?.[ids.value.uid]?.p;\n  const css = computed(() => props?.css);\n  watch(\n    css,\n    (newCss) => {\n      newCss = transformCssPropToDeclaration(ids.value, newCss);\n      if (rule) {\n        sheet.deleteRule(rule);\n      }\n      rule = sheet.pushDeclaration(\n        ids.value.uid,\n        \"p\",\n        newCss,\n        rule,\n        { ...loc, type: \"c\" }\n      );\n    },\n    {\n      immediate: !rule\n    }\n  );\n  onScopeDispose(() => rule && sheet.deleteRule(rule));\n}\nfunction transformCssPropToDeclaration(ids, css) {\n  const declaration = {};\n  if (css) {\n    const targetId = `.${ids.uniqueClassName}${ids.componentId}`;\n    declaration[targetId] = Object.assign(declaration[targetId] || {}, css);\n  }\n  return declaration;\n}\n\nconst defaultRuntimeOptions = {\n  theme: {},\n  utils: {},\n  tokensHelperConfig: {},\n  multiApp: false,\n  colorSchemeMode: \"media\",\n  dev: process.env.NODE_ENV !== \"production\"\n};\nconst plugin = {\n  install(app, options) {\n    options = Object.assign(defaultRuntimeOptions, options);\n    const { theme, tokensHelperConfig, dev, multiApp, colorSchemeMode, utils } = options;\n    const themeSheet = usePinceauThemeSheet(theme, tokensHelperConfig, colorSchemeMode);\n    if (dev && (import.meta.hot || process.server)) {\n      import('./chunks/debug.mjs').then(({ usePinceauRuntimeDebug }) => usePinceauRuntimeDebug(tokensHelperConfig));\n    }\n    const multiAppId = multiApp ? nanoid(6) : void 0;\n    const runtimeSheet = usePinceauRuntimeSheet(themeSheet.$tokens, utils, colorSchemeMode, multiAppId);\n    function usePinceauRuntime(props = {}, variants, computedStyles) {\n      const instance = getCurrentInstance();\n      let loc;\n      if (dev && (import.meta.hot || process.server)) {\n        const { __file: file, __name: name } = instance.vnode.type;\n        loc = { file, name };\n      }\n      const classes = ref({\n        // Variants class\n        v: \"\",\n        // Unique class\n        c: \"\"\n      });\n      const ids = usePinceauRuntimeIds(instance, classes);\n      if (computedStyles && Object.keys(computedStyles).length > 0) {\n        usePinceauComputedStyles(ids, computedStyles, runtimeSheet, loc);\n      }\n      let dynamicVariantClasses;\n      if (variants && Object.keys(variants).length > 0) {\n        const { variantsClasses } = usePinceauVariants(ids, variants, props, runtimeSheet, classes, loc);\n        dynamicVariantClasses = variantsClasses;\n      }\n      if (props?.css && Object.keys(props?.css).length > 0) {\n        usePinceauCssProp(ids, props, runtimeSheet, loc);\n      }\n      return { $pinceau: computed(() => [classes.value.v, classes.value.c, dynamicVariantClasses?.value?.join(\" \")].join(\" \")) };\n    }\n    app.config.globalProperties.$pinceauRuntime = usePinceauRuntime;\n    app.config.globalProperties.$pinceauTheme = themeSheet;\n    app.config.globalProperties.$pinceauSsr = { get: () => runtimeSheet.toString() };\n    app.provide(\"pinceauRuntime\", usePinceauRuntime);\n    app.provide(\"pinceauTheme\", themeSheet);\n  }\n};\n\nfunction usePinceauRuntime(props, variants, computedStyles) {\n  return inject(\"pinceauRuntime\")(props, variants, computedStyles);\n}\nfunction usePinceauTheme() {\n  return inject(\"pinceauTheme\");\n}\nconst cssProp = {\n  type: Object,\n  required: false,\n  default: {}\n};\nfunction computedStyle(defaultValue, required = false) {\n  return {\n    type: [String, Object],\n    default: defaultValue,\n    required\n  };\n}\n\nexport { computedStyle, createTokensHelper, cssProp, plugin, resolveCssProperty, stringify, usePinceauRuntime, usePinceauTheme };\n",
      "start": 1707500035458,
      "end": 1707500035720,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1707500035720,
      "end": 1707500035720,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1707500035721,
      "end": 1707500035721,
      "order": "pre"
    },
    {
      "name": "pinceau-transforms",
      "start": 1707500035721,
      "end": 1707500035721,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1707500035721,
      "end": 1707500035721,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1707500035721,
      "end": 1707500035721,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1707500035721,
      "end": 1707500035721,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1707500035721,
      "end": 1707500035721,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1707500035721,
      "end": 1707500035721,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1707500035721,
      "end": 1707500035721,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1707500035721,
      "end": 1707500035721,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1707500035721,
      "end": 1707500035721,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1707500035721,
      "end": 1707500035721,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1707500035721,
      "end": 1707500035721,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1707500035721,
      "end": 1707500035721,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1707500035721,
      "end": 1707500035721,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1707500035721,
      "end": 1707500035721,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1707500035721,
      "end": 1707500035721,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { ref, computed, watch, onScopeDispose, unref, getCurrentInstance, inject } from \"vue\";\nimport { nanoid } from \"nanoid\";\nimport { z as stringify, a as resolveCssProperty, c as createTokensHelper, s as set, h as get, n as normalizeConfig, w as walkTokens, p as pathToVarName, e as resolveReferences, g as resolveThemeRule } from \"./shared/pinceau.3988746b.mjs\";\nimport { kebabCase } from \"scule\";\nimport { defu } from \"defu\";\nconst HYDRATION_SELECTOR = \".phy[--]\";\nfunction usePinceauRuntimeSheet($tokens, initialUtils = {}, colorSchemeMode, appId) {\n  const sheet = ref();\n  const utils = ref(initialUtils);\n  const cache = {};\n  const stringify$1 = (decl, loc) => stringify(\n    decl,\n    (property, value, style, selectors) => resolveCssProperty(\n      property,\n      value,\n      style,\n      selectors,\n      [],\n      { $tokens, utils: utils.value, options: { colorSchemeMode, runtime: true } },\n      loc\n    )\n  );\n  function resolveStylesheet() {\n    const global = globalThis || window;\n    let style;\n    let hydratableSheet;\n    if (global && global.document) {\n      const fullId = `pinceau-runtime${appId ? `-${appId}` : \"\"}`;\n      const doc = global.document;\n      style = doc.querySelector(`style#${fullId}`);\n      if (!style) {\n        const styleNode = doc.createElement(\"style\");\n        styleNode.id = fullId;\n        styleNode.type = \"text/css\";\n        style = doc.head.appendChild(styleNode);\n      }\n      hydratableSheet = doc.querySelector(`style#pinceau-runtime-hydratable${appId ? `-${appId}` : \"\"}`);\n    }\n    sheet.value = style?.sheet || getSSRStylesheet();\n    return hydratableSheet ? hydrateStylesheet(hydratableSheet) : void 0;\n  }\n  function hydrateStylesheet(el) {\n    const hydratableRules2 = {};\n    for (const _rule of Object.entries(el?.sheet?.cssRules || sheet.value?.cssRules || {})) {\n      const [index, rule] = _rule;\n      const uids = resolveUid(rule);\n      if (!uids || !uids.uid) {\n        continue;\n      }\n      if (!hydratableRules2[uids.uid]) {\n        hydratableRules2[uids.uid] = {};\n      }\n      const newIndex = sheet.value.insertRule(rule.cssText, Number(index));\n      hydratableRules2[uids.uid][uids.type] = sheet.value.cssRules.item(newIndex);\n    }\n    if (el) {\n      el.remove();\n    }\n    return hydratableRules2;\n  }\n  function toString() {\n    if (!sheet.value) {\n      return \"\";\n    }\n    return Object.entries(sheet.value.cssRules).reduce(\n      (acc, [, rule]) => {\n        acc += `${rule?.cssText} ` || \"\";\n        return acc;\n      },\n      \"\"\n    );\n  }\n  function pushDeclaration(uid, type, declaration, previousRule, loc) {\n    if (!Object.keys(declaration).length) {\n      return;\n    }\n    const cssText = stringify$1(\n      {\n        \"@media\": {\n          // Mark inserted declaration with unique id and type of runtime style\n          [HYDRATION_SELECTOR]: { \"--puid\": `${uid}-${type}` },\n          ...declaration\n        }\n      },\n      loc\n    );\n    if (!cssText) {\n      return;\n    }\n    if (previousRule) {\n      deleteRule(previousRule);\n    }\n    const ruleId = sheet.value.insertRule(cssText);\n    return sheet.value.cssRules[ruleId];\n  }\n  function deleteRule(rule) {\n    const ruleIndex = Object.values(sheet.value.cssRules).indexOf(rule);\n    if (typeof ruleIndex === \"undefined\" || isNaN(ruleIndex)) {\n      return;\n    }\n    try {\n      sheet.value.deleteRule(ruleIndex);\n    } catch (e) {\n    }\n  }\n  const hydratableRules = resolveStylesheet();\n  return {\n    stringify: stringify$1,\n    cache,\n    pushDeclaration,\n    deleteRule,\n    sheet,\n    toString,\n    hydratableRules\n  };\n}\nfunction getSSRStylesheet() {\n  return {\n    cssRules: [],\n    insertRule(cssText, index = this.cssRules.length) {\n      this.cssRules.splice(index, 1, { cssText });\n      return index;\n    },\n    deleteRule(index) {\n      delete this.cssRules[index];\n    }\n  };\n}\nfunction resolveUid(rule) {\n  const uidRule = rule.cssRules && rule.cssRules.length ? Object.entries(rule?.cssRules).find(([_, rule2]) => rule2.selectorText === HYDRATION_SELECTOR) : void 0;\n  if (!uidRule) {\n    return;\n  }\n  const uidRegex = /--puid:(.*)?-(c|v|p)?/m;\n  const [, uid, type] = uidRule[1].cssText.match(uidRegex);\n  if (!uid) {\n    return;\n  }\n  return { uid, type };\n}\nfunction usePinceauRuntimeIds(instance, classes, _) {\n  let uid;\n  const el = instance?.vnode?.el;\n  if (el && el.classList) {\n    el.classList.forEach(\n      (elClass) => {\n        if (uid) {\n          return;\n        }\n        if (elClass.startsWith(\"pc-\")) {\n          uid = elClass.split(\"pc-\")[1];\n        }\n      }\n    );\n  } else {\n    uid = nanoid(6);\n  }\n  const scopeId = instance?.vnode?.type?.__scopeId;\n  const ids = {\n    uid,\n    componentId: scopeId ? `[${scopeId}]` : \"\",\n    uniqueClassName: `pc-${uid}`\n  };\n  classes.value.c = ids.uniqueClassName;\n  return computed(() => ids);\n}\nfunction usePinceauThemeSheet(initialTheme, tokensHelperConfig = {}, colorSchemeMode) {\n  const sheet = ref();\n  const theme = ref(initialTheme || {});\n  tokensHelperConfig = Object.assign(\n    {\n      key: \"variable\"\n    },\n    tokensHelperConfig || {}\n  );\n  const $tokens = createTokensHelper(\n    theme,\n    tokensHelperConfig\n  );\n  let cache = {};\n  resolveStylesheet();\n  if (void 0) {\n    (void 0).on(\n      \"pinceau:themeUpdate\",\n      (newTheme) => {\n        const styleNode = document.createElement(\"style\");\n        styleNode.id = \"pinceau-theme\";\n        styleNode.textContent = newTheme.css;\n        sheet.value.ownerNode.replaceWith(styleNode);\n        sheet.value = styleNode.sheet;\n        hydrateStylesheet(sheet.value.cssRules);\n      }\n    );\n  }\n  function findThemeSheet(document2) {\n    for (const sheet2 of document2.styleSheets) {\n      if (sheet2?.ownerNode?.textContent.includes(\"--pinceau-mq\")) {\n        return sheet2.ownerNode;\n      }\n    }\n  }\n  function resolveStylesheet() {\n    const global = globalThis || window;\n    if (global && global.document) {\n      let sheetElement = document.querySelector(\"#pinceau-theme\");\n      if (!sheetElement) {\n        sheetElement = findThemeSheet(document);\n      }\n      sheet.value = sheetElement?.sheet;\n      if (sheet.value) {\n        hydrateStylesheet(sheet.value?.cssRules);\n      }\n    }\n  }\n  function hydrateStylesheet(cssRules) {\n    cache = {};\n    Object.entries(cssRules || {}).forEach(\n      ([_, rule]) => {\n        if (rule?.type !== 4 && !rule?.cssText?.includes(\"--pinceau-mq\")) {\n          return false;\n        }\n        let currentTheme = \"initial\";\n        rule.cssText.match(/--([\\w-]+)\\s*:\\s*(.+?);/gm)?.forEach((match) => {\n          const [variable, value] = match.replace(\";\", \"\").split(/:\\s(.*)/s);\n          if (variable === \"--pinceau-mq\") {\n            currentTheme = value;\n            if (!cache[value]) {\n              const ruleReference = Object.entries(rule?.cssRules || {}).find(([_2, cssRule]) => cssRule?.cssText.includes(`--pinceau-mq: ${value}`))?.[1];\n              if (ruleReference) {\n                cache[value] = ruleReference;\n              }\n            }\n            return;\n          }\n          const path = [...variable.substring(2).split(\"-\")];\n          set(theme.value, path, getSetValue(path, value, variable, currentTheme));\n        });\n      }\n    );\n  }\n  function updateTheme(value) {\n    const mqKeys = Array.from(/* @__PURE__ */ new Set([\"dark\", \"light\", ...Object.keys(value?.media || {}), ...Object.keys(theme.value?.media || {})]));\n    const config = normalizeConfig(value || {}, mqKeys, true);\n    walkTokens(config, (token, _, paths) => updateToken(paths, token.value));\n  }\n  function updateToken(path, value, mq = \"initial\") {\n    if (typeof value === \"object\") {\n      Object.entries(value).forEach(([mq2, mqValue]) => updateToken(path, mqValue, mq2));\n      return;\n    }\n    const varName = pathToVarName(path);\n    if (!cache?.[mq]) {\n      createMqRule(mq);\n    }\n    const resolvedValue = resolveReferences(void 0, value, [], { $tokens });\n    set(\n      theme.value,\n      path,\n      getSetValue(path, resolvedValue, varName, mq)\n    );\n    cache?.[mq]?.style.setProperty(varName, resolvedValue);\n  }\n  function reactiveToken(path) {\n    return computed(\n      {\n        get() {\n          return get(theme.value, `${path}.value`);\n        },\n        set(v) {\n          updateToken(path, v);\n        }\n      }\n    );\n  }\n  function getSetValue(path, value, variable, mq = \"initial\") {\n    const setValue = { value, variable: `var(${variable})` };\n    const existingValue = get(theme.value, path);\n    if (existingValue && !variable.startsWith(\"--media\")) {\n      if (typeof existingValue?.value === \"object\") {\n        setValue.value = { ...existingValue.value, [mq]: value };\n      } else {\n        setValue.value = { initial: existingValue.value, [mq]: value };\n      }\n    }\n    return setValue;\n  }\n  function createMqRule(mq) {\n    if (cache?.[mq]) {\n      return cache?.[mq];\n    }\n    const mqRule = resolveThemeRule(mq, \"\", theme.value, colorSchemeMode);\n    const newRule = sheet.value.insertRule(mqRule, sheet.value.cssRules.length);\n    cache[mq] = sheet.value.cssRules.item(newRule).cssRules[0];\n    return cache[mq];\n  }\n  return {\n    $tokens,\n    updateToken,\n    updateTheme,\n    reactiveToken,\n    resolveStylesheet,\n    theme\n  };\n}\nfunction usePinceauComputedStyles(ids, computedStyles, sheet, loc) {\n  let rule = sheet.hydratableRules?.[ids.value.uid]?.c;\n  watch(\n    () => computedStyles,\n    (newComputedStyles) => {\n      newComputedStyles = computedStylesToDeclaration(ids.value, newComputedStyles);\n      rule = sheet.pushDeclaration(\n        ids.value.uid,\n        \"c\",\n        newComputedStyles,\n        rule,\n        { ...loc, type: \"c\" }\n      );\n    },\n    {\n      immediate: !rule,\n      deep: true\n    }\n  );\n  onScopeDispose(() => rule && sheet.deleteRule(rule));\n}\nfunction computedStylesToDeclaration(ids, computedStyles) {\n  const declaration = {};\n  const targetId = `.${ids.uniqueClassName}${ids.componentId}`;\n  if (computedStyles && Object.keys(computedStyles).length) {\n    declaration[targetId] = declaration[targetId] || {};\n    for (const [varName, _value] of Object.entries(computedStyles)) {\n      const value = unref(_value);\n      if (varName === \"css\") {\n        declaration[targetId] = Object.assign(declaration[targetId], value);\n        continue;\n      }\n      if (typeof value === \"object\") {\n        for (const [mqId, mqPropValue] of Object.entries(value)) {\n          const _value2 = unref(mqPropValue);\n          if (!_value2) {\n            continue;\n          }\n          if (mqId === \"initial\") {\n            if (!declaration[targetId]) {\n              declaration[targetId] = {};\n            }\n            if (!declaration[targetId]) {\n              declaration[targetId] = {};\n            }\n            declaration[targetId][`--${varName}`] = _value2;\n          }\n          const mediaId = `@${mqId}`;\n          if (!declaration[mediaId]) {\n            declaration[mediaId] = {};\n          }\n          if (!declaration[mediaId][targetId]) {\n            declaration[mediaId][targetId] = {};\n          }\n          declaration[mediaId][targetId][`--${kebabCase(varName)}`] = _value2;\n        }\n      } else {\n        const _value2 = unref(value);\n        if (_value2) {\n          declaration[targetId][`--${kebabCase(varName)}`] = _value2;\n        }\n      }\n    }\n  }\n  return declaration;\n}\nconst usePinceauVariants = (ids, variants, props, sheet, classes, loc) => {\n  let rule = sheet.hydratableRules?.[ids.value.uid]?.v;\n  const variantsState = computed(() => variants ? resolveVariantsState(ids.value, props, variants) : {});\n  const variantsClasses = ref([]);\n  watch(\n    variantsState,\n    ({ cacheId, variantsProps }) => {\n      let variantClass;\n      if (sheet.cache[cacheId]) {\n        const cachedRule = sheet.cache[cacheId];\n        rule = cachedRule.rule;\n        variantClass = cachedRule.variantClass;\n        if (cachedRule?.classes) {\n          variantsClasses.value = cachedRule.classes;\n        }\n        cachedRule.count++;\n      } else {\n        variantClass = `pv-${nanoid(6)}`;\n        const { declaration, classes: classes2 } = variantsToDeclaration(variantClass, ids.value, variants, variantsProps);\n        variantsClasses.value = classes2;\n        rule = sheet.pushDeclaration(ids.value.uid, \"v\", declaration, void 0, { ...loc, type: \"v\" });\n        sheet.cache[cacheId] = { rule, variantClass, classes: classes2, count: 1 };\n      }\n      classes.value.v = variantClass;\n    },\n    {\n      immediate: true\n    }\n  );\n  onScopeDispose(\n    () => {\n      const state = variantsState?.value;\n      const cachedRule = sheet.cache?.[state.cacheId];\n      if (cachedRule) {\n        cachedRule.count--;\n        if (cachedRule.count <= 0) {\n          sheet.deleteRule(cachedRule.rule);\n          delete sheet.cache[state.cacheId];\n        }\n      }\n    }\n  );\n  return { variantsClasses };\n};\nfunction variantsToDeclaration(variantClass, ids, variants, props) {\n  let classes = [];\n  const declaration = {};\n  if (props && Object.keys(props).length) {\n    const targetId = `.${variantClass}`;\n    for (const [propName, propValue] of Object.entries(props)) {\n      if (typeof propValue === \"object\") {\n        for (const [mqId, mqPropValue] of Object.entries(propValue)) {\n          const _value = mqPropValue?.toString() || mqPropValue;\n          const variantValue = variants[propName][_value];\n          if (!variantValue) {\n            continue;\n          }\n          if (!declaration[targetId]) {\n            declaration[targetId] = {};\n          }\n          if (typeof variantValue === \"string\" || Array.isArray(variantValue) || variantValue?.$class) {\n            const classAttr = typeof variantValue === \"string\" || Array.isArray(variantValue) ? variantValue : variantValue.$class;\n            classes = [\n              ...classes,\n              ...typeof classAttr === \"string\" ? classAttr.split(\" \") : classAttr\n            ];\n            delete variantValue.$class;\n          }\n          if (mqId === \"initial\") {\n            if (!declaration[targetId]) {\n              declaration[targetId] = {};\n            }\n            declaration[targetId] = defu(declaration[targetId], variantValue);\n          }\n          const mediaId = `@${mqId}`;\n          if (!declaration[mediaId]) {\n            declaration[mediaId] = {};\n          }\n          if (!declaration[mediaId][targetId]) {\n            declaration[mediaId][targetId] = {};\n          }\n          declaration[mediaId][targetId] = defu(declaration[mediaId][targetId], variantValue);\n        }\n      } else {\n        const _value = propValue?.toString?.() || propValue;\n        const variantValue = variants?.[propName]?.[_value];\n        if (!variantValue) {\n          continue;\n        }\n        if (!declaration[targetId]) {\n          declaration[targetId] = {};\n        }\n        declaration[targetId] = defu(declaration[targetId], variantValue);\n      }\n    }\n  }\n  return { declaration, classes };\n}\nfunction resolveVariantsState(ids, props, variants) {\n  if (!props || !variants) {\n    return {};\n  }\n  let cacheId = ids.componentId;\n  const variantsProps = Object.entries(props).reduce(\n    (acc, [propName, propValue]) => {\n      if (!variants[propName]) {\n        return acc;\n      }\n      if (typeof propValue === \"object\") {\n        Object.entries(propValue).forEach(([key, value]) => cacheId += `${propName}:${key}:${value}|`);\n      } else {\n        cacheId += `${propName}:${propValue}|`;\n      }\n      acc[propName] = propValue;\n      return acc;\n    },\n    {}\n  );\n  return { cacheId, variantsProps };\n}\nfunction usePinceauCssProp(ids, props, sheet, loc) {\n  let rule = sheet.hydratableRules?.[ids.value.uid]?.p;\n  const css = computed(() => props?.css);\n  watch(\n    css,\n    (newCss) => {\n      newCss = transformCssPropToDeclaration(ids.value, newCss);\n      if (rule) {\n        sheet.deleteRule(rule);\n      }\n      rule = sheet.pushDeclaration(\n        ids.value.uid,\n        \"p\",\n        newCss,\n        rule,\n        { ...loc, type: \"c\" }\n      );\n    },\n    {\n      immediate: !rule\n    }\n  );\n  onScopeDispose(() => rule && sheet.deleteRule(rule));\n}\nfunction transformCssPropToDeclaration(ids, css) {\n  const declaration = {};\n  if (css) {\n    const targetId = `.${ids.uniqueClassName}${ids.componentId}`;\n    declaration[targetId] = Object.assign(declaration[targetId] || {}, css);\n  }\n  return declaration;\n}\nconst defaultRuntimeOptions = {\n  theme: {},\n  utils: {},\n  tokensHelperConfig: {},\n  multiApp: false,\n  colorSchemeMode: \"media\",\n  dev: false\n};\nconst plugin = {\n  install(app, options) {\n    options = Object.assign(defaultRuntimeOptions, options);\n    const { theme, tokensHelperConfig, dev, multiApp, colorSchemeMode, utils } = options;\n    const themeSheet = usePinceauThemeSheet(theme, tokensHelperConfig, colorSchemeMode);\n    if (dev && false) {\n      null.then(({ usePinceauRuntimeDebug }) => usePinceauRuntimeDebug(tokensHelperConfig));\n    }\n    const multiAppId = multiApp ? nanoid(6) : void 0;\n    const runtimeSheet = usePinceauRuntimeSheet(themeSheet.$tokens, utils, colorSchemeMode, multiAppId);\n    function usePinceauRuntime2(props = {}, variants, computedStyles) {\n      const instance = getCurrentInstance();\n      let loc;\n      if (dev && false) {\n        const { __file: file, __name: name } = instance.vnode.type;\n        loc = { file, name };\n      }\n      const classes = ref({\n        // Variants class\n        v: \"\",\n        // Unique class\n        c: \"\"\n      });\n      const ids = usePinceauRuntimeIds(instance, classes);\n      if (computedStyles && Object.keys(computedStyles).length > 0) {\n        usePinceauComputedStyles(ids, computedStyles, runtimeSheet, loc);\n      }\n      let dynamicVariantClasses;\n      if (variants && Object.keys(variants).length > 0) {\n        const { variantsClasses } = usePinceauVariants(ids, variants, props, runtimeSheet, classes, loc);\n        dynamicVariantClasses = variantsClasses;\n      }\n      if (props?.css && Object.keys(props?.css).length > 0) {\n        usePinceauCssProp(ids, props, runtimeSheet, loc);\n      }\n      return { $pinceau: computed(() => [classes.value.v, classes.value.c, dynamicVariantClasses?.value?.join(\" \")].join(\" \")) };\n    }\n    app.config.globalProperties.$pinceauRuntime = usePinceauRuntime2;\n    app.config.globalProperties.$pinceauTheme = themeSheet;\n    app.config.globalProperties.$pinceauSsr = { get: () => runtimeSheet.toString() };\n    app.provide(\"pinceauRuntime\", usePinceauRuntime2);\n    app.provide(\"pinceauTheme\", themeSheet);\n  }\n};\nfunction usePinceauRuntime(props, variants, computedStyles) {\n  return inject(\"pinceauRuntime\")(props, variants, computedStyles);\n}\nfunction usePinceauTheme() {\n  return inject(\"pinceauTheme\");\n}\nconst cssProp = {\n  type: Object,\n  required: false,\n  default: {}\n};\nfunction computedStyle(defaultValue, required = false) {\n  return {\n    type: [String, Object],\n    default: defaultValue,\n    required\n  };\n}\nexport { computedStyle, createTokensHelper, cssProp, plugin, resolveCssProperty, stringify, usePinceauRuntime, usePinceauTheme };\n",
      "start": 1707500035721,
      "end": 1707500036083,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1707500036084,
      "end": 1707500036084,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1707500036084,
      "end": 1707500036084,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1707500036084,
      "end": 1707500036084,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1707500036084,
      "end": 1707500036084,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1707500036084,
      "end": 1707500036086,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1707500036086,
      "end": 1707500036086,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1707500036086,
      "end": 1707500036086,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1707500036086,
      "end": 1707500036086,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1707500036087,
      "end": 1707500036087,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1707500036087,
      "end": 1707500036087,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1707500036087,
      "end": 1707500036087,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1707500036087,
      "end": 1707500036087,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1707500036087,
      "end": 1707500036087,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1707500036087,
      "end": 1707500036087,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1707500036087,
      "end": 1707500036088,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1707500036088,
      "end": 1707500036088,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1707500036088,
      "end": 1707500036089,
      "order": "normal"
    }
  ]
}
